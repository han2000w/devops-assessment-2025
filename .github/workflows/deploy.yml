name: Receipt workflow

on:
  push:
    branches:
      - main
  workflow_dispatch:

# workflow의 기본 shell로 bash 사용
defaults:
  run:
    shell: bash

env:
  IMAGE_NAME: spendit-api
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_REGION: ap-northeast-2
  CONTAINER_REGISTRY: 123456789012.dkr.ecr.ap-northeast-2.amazonaws.com
  GITOPS_REPO: spendit/spendit-infra # GitOps를 사용한 서비스 배포시 배포 manifest가 저장될 레포지토리

jobs:
  # Container 이미지 Build와 Push를 수행하는 job
  build_and_push_docker_image:    
    runs-on: ubuntu-latest
    environment: production
    outputs:
      sha_short: ${{ steps.vars.outputs.sha_short }}  # Container 이미지의 tag로 사용될 sha의 축약버전
    steps:
      - name: action-slack   # Workflow 시작알림 slack으로 전송
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          fields: author,commit
          custom_payload: |
            {
              text: `:warning: Start Build spendit-api/main(${process.env.AS_COMMIT})`,
              attachments: [{
              color: '#0101DF',
              text: `by ${process.env.AS_AUTHOR}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Declare sha short  # Container 이미지의 tag로 사용될 short 버전 sha 생성
        id: vars
        shell: bash
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials # AWS 크리덴셜 설정
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR  # ECR 로그인
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push
        uses: docker/build-push-action@v4.0.0
        with:
          context: ./app
          file: ./app/Dockerfile
          tags: ${{ env.CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.vars.outputs.sha_short }},${{ env.CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          push: true

  # 오픈소스 Container 이미지 취약점 스캔툴인 Trivy 사용하여 보안 취약점 확인
  scan: 
    runs-on: ubuntu-latest
    needs: [build_and_push_docker_image]
    environment: production
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build_and_push_docker_image.outputs.sha_short }}
          format: 'json'
          # exit-code: '1'   # exit-code: '1' 설정시 취약점발견되면 workflow 를 실패 시킨다.
          output: "result.json"
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

      - name: Make Trivy security issue  # 위의 스캔에서 발견된 취약점을 github의 Issue로 등록한다.
        uses: CemitDigital/trivy-report-issue-action@v1.1
        with:
          # Token passed by GitHub actions, required for access to GitHub issues
          token: ${{ secrets.GITHUB_TOKEN }}

          # File with scan results
          input-filename: "result.json"

          # Label name
          # Default: vulnerability (this label must be created in advance)
          label: 'vulnerability'

          # Assignees, comma separated
          # Default: ''
          # Example: 'monalisa,hubot'
          assignee: ''

          # If set the new issues will be assigned to the specified project
          # Default: ''
          project-id: ''

  # 과제에 제공된 test-api.sh를 활용하여 이미지가 정상적으로 동작하는지 확인하는 테스트 단계
  test: 
    runs-on: ubuntu-latest
    needs: [build_and_push_docker_image]
    environment: production
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create network
        run: docker network create app-net

      - name: Run PostgreSQL
        run: |
          docker run -d -p 5432:5432 --name db --network app-net \
            -e POSTGRES_USER=receipts_user -e POSTGRES_PASSWORD=receipts_password -e POSTGRES_DB=receipts_db \
            -v ./init-db.sql:/docker-entrypoint-initdb.d/init-db.sql postgres:15-alpine
          sleep 5

      - name: Run API container
        run: |
          docker run -d -p 8000:8000 --name api --network app-net \
            -e DATABASE_URL=postgresql://receipts_user:receipts_password@db:5432/receipts_db \
            ${{ env.CONTAINER_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build_and_push_docker_image.outputs.sha_short }}
          sleep 5

      - name: Run API integration tests
        run: |
          chmod +x ./test-api.sh
          ./test-api.sh

  # 새로 빌드된 Container 이미지를 사용하도록 gitops 저장소의 manifest를 업데이트 후 commit하는 단계
  update_helm_chart:
    runs-on: ubuntu-latest
    needs:
      - build_and_push_docker_image
      - scan
      - test
    environment: production
    env:
      BUILD_ID: ${{ needs.build_and_push_docker_image.outputs.sha_short }}
    steps:
      - name: Checkout GitOps repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITOPS_REPO }}        
          token: ${{ secrets.GITOPS_TOKEN }} 
          ref: main
    
      - name: Substitute environment variables of The Helm value
        uses: nowactions/envsubst@v1
        with:
          input: gitops/infra/helm/spendit-api/values.template-prod.yaml
          output: gitops/infra/helm/spendit-api/env/prod/values.yaml

      - name: Commit and push HELM changes
        run: |
          git config --local user.email "server@spendit.com"
          git config --local user.name "helm"
          git add .
          git commit -m "Commit HELM changes: ${{ env.IMAGE_NAME }} ${{ env.BUILD_ID }}"
          git push --force origin main

      - name: Deploy to Production (Simulated)
        run: |
          echo "Deploying to production..."
          echo "Deployment completed"
          # 실제 환경에서는:
          # GitOps repo에 push된 최신 manifest를 EKS의 CD툴인 ArgoCD가 자동으로 감지하여 최신버전으로 Sync를 수행함
          # 만약 신규 배포 버전에 에러가 감지되면 ArgoCD의 Slack 알림으로 감지하여 ArgoCD의 UI를 통해 손쉽게 이전 버전으로 롤백 가능

  # 모든 workflow의 job이 완료 된 후 최종 결과를 slack으로 전송
  notify_end:
    runs-on: ubuntu-latest
    needs:
      - build_and_push_docker_image
      - scan
      - test
      - update_helm_chart
    if: always()
    environment: production
    steps:
      - name: action-slack(success)
        uses: 8398a7/action-slack@v3
        with:
            status: success
            author_name: spendit-api main
            fields: repo,message,commit,author,action,eventName,ref,workflow,took
        env:
            SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: success()

      - name: action-slack(failure)
        uses: 8398a7/action-slack@v3
        with:
            status: failure
            author_name: spendit-api main
            fields: repo,message,commit,author,action,eventName,ref,workflow,took
        env:
            SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: failure()
